import pandas as pd
import numpy as np
import json
import requests

# Read clean data file
df = pd.read_pickle('clean_data.pkl')

def gen_request_data(coords_str):
    """
    From the original POLYLINE data, prepare the JSON payload for POST requests for the trace_attribute action of Meili.

    Args:
        coords_str (str): original POLYLINE data of the GPS trace

    Returns:
        str: JSON payload of the required format
    """
    # Convert the string into a list of lists
    coords_list = eval(coords_str)

    # Convert the list into desired JSON structure
    # Convert it into a DataFrame with two columns
    coords_df = pd.DataFrame(coords_list, columns=['lon', 'lat'])
    # Change the column order
    coords_df = coords_df[['lat', 'lon']]
    # Convert the DataFrame into a JSON
    meili_coordinates = coords_df.to_json(orient='records')

    # Providing needed data for the body of Meili's request
    meili_head = '{"shape":'
    # Parameters of the request
    meili_tail = ""","search_radius": 150, "shape_match":"map_snap", "costing":"auto", "format":"osrm"}"""

    # Combining all the string into a single request
    meili_request_body = meili_head + meili_coordinates + meili_tail

    return meili_request_body

def get_meili_response(meili_request_body_str):
    """
    Take the JSON payload, send a request to Meili, parse the JSON response if the response was correct.

    Args:
        meili_request_body_str (str): JSON payload for the POST request, generated by the function gen_request_data

    Raises:
        Exception: Raises an exception and print the request code and request message if the response from Meili was
        incorrect.

    Returns:
        str: response from the trace_attribute action
    """
    # The URL of our local Valhalla server
    # We're using the 'trace_attributes' action
    url = "http://localhost:8002/trace_attributes"

    # Providing headers to the request
    headers = {'Content-type': 'application/json'}

    # Send the request
    r = requests.post(url, data=meili_request_body_str, headers=headers)

    # Check if the response from Meili was correct
    if r.status_code == 200:

        # Parsing the JSON response
        response_text = json.loads(r.text)

        return response_text
    else:
        raise Exception("Request failed with status code {}: {}".format(r.status_code, r.text))


def matched_points(response_text):
    """
    Get the list of GPS coordinates of the matched points and convert it into a JSON format

    Args:
        response_text (str): response from the trace_attribute action

    Returns:
        str: list of matched points in JSON format
    """
    if response_text is None:
        return np.nan

    matched_trace = response_text['matched_points']

    if matched_trace:
        matched_trace_df = pd.DataFrame([(p['lat'], p['lon']) for p in matched_trace], columns=['lat', 'lon'])
        matched_trace_json = matched_trace_df.to_json(orient='records')

        return matched_trace_json
    else:
        return np.nan


def matched_path(response_text):
    """
    Get the matched path and convert it into a JSON format

    Args:
        response_text (str): response from the trace_attribute action

    Returns:
        str: matched path in JSON format
    """
    if response_text is None:
        return np.nan

    matched_path = response_text['shape']

    if matched_path:
        # Get matched path by decoding the `shape` item
        import decode

        matched_path = decode.decode(matched_path)
        matched_path_df = pd.DataFrame(matched_path, columns=['lon', 'lat'])
        matched_path_df = matched_path_df[['lat', 'lon']]
        matched_path_json = matched_path_df.to_json(orient='records')

        return matched_path_json
    else:
        return np.nan


def wayid_seq(response_text):
    """
    Get the sequence of way ID

    Args:
        response_text (str): response from the trace_attribute action

    Returns:
        list: sequence of way ID, list of int
    """
    if response_text is None:
        return np.nan

    edges = response_text['edges']

    if edges:
        # Get sequence of way ID
        seq = [e['way_id'] for e in edges]

        # Remove only consecutive duplicates in the way ID sequence
        # Because when the taxi is on the same road, we only count the way ID once
        seq = pd.Series(seq)
        seq = seq.loc[seq.shift() != seq]
        seq = seq.tolist()

        return seq
    else:
        return np.nan


def get_wayid_seq(coords_str):
    """
    From the original POLYLINE data, make a request to Meili, get the sequence of way ID from the response.

    Args:
        coords_str (str): original POLYLINE data of the GPS trace

    Returns:
        list: sequence of way ID, list of int
    """
    meili_request_body_str = gen_request_data(coords_str)

    try:
        response_text = get_meili_response(meili_request_body_str)
    except Exception as e:
        print("Error: {}".format(e))  # Print the error
        response_text = None

    seq = wayid_seq(response_text)

    return seq


df['wayid_seq'] = df['POLYLINE'].apply(get_wayid_seq)

# Save the result as .pkl file
df.to_pickle('map_matching_result.pkl')